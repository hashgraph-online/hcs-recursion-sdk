<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Space Agar - Advanced</title>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        overflow: hidden;
        width: 100%;
        height: 100%;
        font-family: Arial, sans-serif;
        background-color: #000;
      }
      #game-container {
        position: relative;
        width: 100%;
        height: 100%;
      }
      #hud {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #fff;
        font-size: 18px;
        text-shadow: 2px 2px 2px rgba(0, 0, 0, 0.5);
      }
      #minimap {
        position: absolute;
        bottom: 10px;
        right: 10px;
        width: 200px;
        height: 200px;
        background-color: rgba(0, 0, 0, 0.5);
        border: 2px solid #fff;
      }
      #ability-bar {
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
      }
      .ability-icon {
        width: 50px;
        height: 50px;
        background-color: rgba(255, 255, 255, 0.2);
        border: 2px solid #fff;
        border-radius: 5px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        color: #fff;
        cursor: pointer;
      }
      #start-screen,
      #game-over-screen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        background-color: rgba(0, 0, 0, 0.7);
        padding: 20px;
        border-radius: 10px;
        color: #fff;
      }
      button {
        background-color: #4caf50;
        border: none;
        color: white;
        padding: 15px 32px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
        margin: 4px 2px;
        cursor: pointer;
        border-radius: 5px;
      }
    </style>
    <script
      data-src="hcs://1/0.0.6614307"
      data-load-order="2"
      data-script-id="threejs"
    ></script>
    <script
      data-src="hcs://1/0.0.6627067"
      data-load-order="3"
      data-script-id="animejs"
    ></script>
    <script
      data-src="hcs://1/0.0.6743172"
      data-load-order="4"
      data-script-id="tweenjs"
    ></script>
    <script
      data-src="hcs://1/0.0.6743157"
      data-load-order="5"
      data-script-id="howlerjs"
    ></script>
    <script
      data-src="hcs://1/0.0.6743198"
      data-load-order="6"
      data-script-id="cannonjs"
    ></script>
  </head>
  <body>
    <div id="game-container">
      <div id="hud">
        <div id="score">Score: 0</div>
        <div id="size">Size: 1.00</div>
        <div id="level">Level: 1</div>
        <div id="stage">Stage: Asteroid</div>
      </div>
      <canvas id="minimap"></canvas>
      <div id="ability-bar">
        <div class="ability-icon" id="ability-pulse">P</div>
        <div class="ability-icon" id="ability-shield">S</div>
        <div class="ability-icon" id="ability-boost">B</div>
      </div>
      <div id="start-screen">
        <h1>Cosmic Absorption Deluxe</h1>
        <p>
          Absorb smaller celestial bodies to grow. Avoid larger ones and
          obstacles!
        </p>
        <p>
          Use WASD or Arrow keys to move. Mouse to aim. Number keys for
          abilities.
        </p>
        <button id="start-button">Start Game</button>
      </div>
      <div id="game-over-screen" style="display: none">
        <h1>Game Over</h1>
        <p>Your final score: <span id="final-score"></span></p>
        <p>Highest level reached: <span id="final-level"></span></p>
        <button id="restart-button">Play Again</button>
      </div>
    </div>
    <script>
      window.HCSReady = async function () {
        while (!window?.CANNON) {
          await new Promise((resolve) => setTimeout(resolve, 1000));
        }
        console.log('All resources loaded, initializing game');

        class Component {}

        class PositionComponent extends Component {
          constructor(x, y, z) {
            super();
            this.x = x;
            this.y = y;
            this.z = z;
          }
        }

        class VelocityComponent extends Component {
          constructor(vx, vy, vz) {
            super();
            this.vx = vx;
            this.vy = vy;
            this.vz = vz;
          }
        }

        class RenderComponent extends Component {
          constructor(mesh) {
            super();
            this.mesh = mesh;
          }
        }

        class PhysicsComponent extends Component {
          constructor(body) {
            super();
            this.body = body;
          }
        }

        class SizeComponent extends Component {
          constructor(size) {
            super();
            this.size = size;
          }
        }

        class PlayerControlledComponent extends Component {
          constructor() {
            super();
            this.abilities = {
              pulse: { cooldown: 0, maxCooldown: 10 },
              shield: { cooldown: 0, maxCooldown: 15, active: false },
              boost: { cooldown: 0, maxCooldown: 5, active: false },
            };
          }
        }

        class AIControlledComponent extends Component {}

        class AbsorbableComponent extends Component {}

        class PowerUpComponent extends Component {
          constructor(type) {
            super();
            this.type = type;
          }
        }

        class ObstacleComponent extends Component {
          constructor(type) {
            super();
            this.type = type;
          }
        }

        class GravityWellComponent extends Component {}
        class WormholeComponent extends Component {
          constructor(exitX, exitY) {
            super();
            this.exitX = exitX;
            this.exitY = exitY;
          }
        }
        class SpaceDustComponent extends Component {}

        class GravityFieldComponent extends Component {
          constructor(strength, radius) {
            super();
            this.strength = strength;
            this.radius = radius;
          }
        }

        class Entity {
          constructor() {
            this.components = new Map();
          }

          addComponent(component) {
            this.components.set(component.constructor, component);
          }

          removeComponent(componentClass) {
            this.components.delete(componentClass);
          }

          getComponent(componentClass) {
            return this.components.get(componentClass);
          }

          hasComponent(componentClass) {
            return this.components.has(componentClass);
          }
        }

        class System {
          constructor(world) {
            this.world = world;
          }

          update(deltaTime) {}
        }

        class PhysicsSystem extends System {
          constructor(world) {
            super(world);
            this.physicsWorld = new CANNON.World();
            this.physicsWorld.gravity.set(0, 0, 0);
          }

          update(deltaTime) {
            this.physicsWorld.step(deltaTime);

            for (let entity of this.world.entities) {
              if (
                entity.hasComponent(PhysicsComponent) &&
                entity.hasComponent(PositionComponent)
              ) {
                const physicsBody = entity.getComponent(PhysicsComponent).body;
                const position = entity.getComponent(PositionComponent);

                position.x = physicsBody.position.x;
                position.y = physicsBody.position.y;
                position.z = physicsBody.position.z;
              }
            }
          }
        }

        class RenderSystem extends System {
          update() {
            for (let entity of this.world.entities) {
              if (
                entity.hasComponent(PositionComponent) &&
                entity.hasComponent(RenderComponent)
              ) {
                const position = entity.getComponent(PositionComponent);
                const render = entity.getComponent(RenderComponent);

                render.mesh.position.set(position.x, position.y, position.z);

                if (entity.hasComponent(SizeComponent)) {
                  const size = entity.getComponent(SizeComponent);
                  render.mesh.scale.set(size.size, size.size, size.size);
                }
              }
            }
          }
        }

        class PlayerControlSystem extends System {
          constructor(world, camera) {
            super(world);
            this.camera = camera;
            this.mouse = new THREE.Vector2();
            this.raycaster = new THREE.Raycaster();
            this.keys = {};
            this.force = new CANNON.Vec3(0, 0, 0);
            this.mouseForce = new CANNON.Vec3(0, 0, 0);
            this.isMouseDown = false;
            this.isTouchActive = false;
            this.touchStartPosition = new THREE.Vector2();

            window.addEventListener('mousemove', (event) =>
              this.handleMouseMove(event)
            );
            window.addEventListener('mousedown', () => {
              this.isMouseDown = true;
            });
            window.addEventListener('mouseup', () => {
              this.isMouseDown = false;
            });
            window.addEventListener('touchstart', (event) =>
              this.handleTouchStart(event)
            );
            window.addEventListener('touchmove', (event) =>
              this.handleTouchMove(event)
            );
            window.addEventListener('touchend', () => {
              this.isTouchActive = false;
            });
            window.addEventListener('keydown', (event) => {
              this.keys[event.key.toLowerCase()] = true;
              if (event.key === '1') this.useAbility('pulse');
              if (event.key === '2') this.useAbility('shield');
              if (event.key === '3') this.useAbility('boost');
            });
            window.addEventListener('keyup', (event) => {
              this.keys[event.key.toLowerCase()] = false;
            });
          }

          handleMouseMove(event) {
            this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
          }

          handleTouchStart(event) {
            if (event.touches.length === 1) {
              this.isTouchActive = true;
              this.touchStartPosition.x = event.touches[0].clientX;
              this.touchStartPosition.y = event.touches[0].clientY;
            }
          }

          handleTouchMove(event) {
            if (this.isTouchActive && event.touches.length === 1) {
              const touch = event.touches[0];
              this.mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
              this.mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
            }
          }

          useAbility(abilityName) {
            const player = this.world.entities.find((e) =>
              e.hasComponent(PlayerControlledComponent)
            );
            if (player) {
              const playerControl = player.getComponent(
                PlayerControlledComponent
              );
              const ability = playerControl.abilities[abilityName];

              if (ability && ability.cooldown <= 0) {
                switch (abilityName) {
                  case 'pulse':
                    this.world.createGravitationalPulse(player);
                    break;
                  case 'shield':
                    this.world.activateShield(player);
                    break;
                  case 'boost':
                    this.world.activateBoost(player);
                    break;
                }
                ability.cooldown = ability.maxCooldown;
              }
            }
          }

          update(deltaTime) {
            const player = this.world.entities.find((e) =>
              e.hasComponent(PlayerControlledComponent)
            );
            if (!player) return;

            const playerControl = player.getComponent(
              PlayerControlledComponent
            );
            const physics = player.getComponent(PhysicsComponent);
            const position = player.getComponent(PositionComponent);
            const size = player.getComponent(SizeComponent);

            for (let ability in playerControl.abilities) {
              if (playerControl.abilities[ability].cooldown > 0) {
                playerControl.abilities[ability].cooldown -= deltaTime;
              }
            }

            this.force.set(0, 0, 0);
            this.mouseForce.set(0, 0, 0);

            if (this.keys['w'] || this.keys['arrowup']) this.force.y += 1;
            if (this.keys['s'] || this.keys['arrowdown']) this.force.y -= 1;
            if (this.keys['a'] || this.keys['arrowleft']) this.force.x -= 1;
            if (this.keys['d'] || this.keys['arrowright']) this.force.x += 1;

            this.raycaster.setFromCamera(this.mouse, this.camera);
            const intersects = this.raycaster.intersectObject(this.world.plane);

            if (
              intersects.length > 0 &&
              (this.isMouseDown || this.isTouchActive)
            ) {
              const target = intersects[0].point;
              this.mouseForce.set(
                target.x - position.x,
                target.y - position.y,
                0
              );
              this.mouseForce.normalize();
            }

            this.force.vadd(this.mouseForce, this.force);

            if (this.force.length() > 0) {
              this.force.normalize();
            }

            const baseSpeed = 12000;
            const speed = playerControl.abilities.boost.active
              ? baseSpeed * 1.5
              : baseSpeed;
            this.force.scale(speed, this.force);

            if (physics && physics.body) {
              physics.body.applyForce(this.force, physics.body.position);

              const maxVelocity = 1000;
              if (physics.body.velocity.length() > maxVelocity) {
                physics.body.velocity.normalize();
                physics.body.velocity.scale(maxVelocity, physics.body.velocity);
              }

              const damping = 0.98;
              physics.body.velocity.scale(damping, physics.body.velocity);
            }

            const minZoom = 300;
            const zoomFactor = 0.1;
            const targetZoom = Math.max(minZoom, size.size * 30);
            this.camera.position.x = position.x;
            this.camera.position.y = position.y;
            this.camera.position.z +=
              (targetZoom - this.camera.position.z) * zoomFactor;
            this.camera.lookAt(position.x, position.y, position.z);
          }
        }

        class CollisionSystem extends System {
          update() {
            const player = this.world.entities.find((e) =>
              e.hasComponent(PlayerControlledComponent)
            );
            if (!player) return;

            const playerPosition = player.getComponent(PositionComponent);
            const playerSize = player.getComponent(SizeComponent);
            const playerControl = player.getComponent(
              PlayerControlledComponent
            );
            const playerPhysics = player.getComponent(PhysicsComponent);
            const playerEvolution = player.getComponent(
              EvolutionaryStageComponent
            );

            for (let entity of this.world.entities) {
              if (entity === player) continue;

              if (entity.hasComponent(AbsorbableComponent)) {
                const entityPosition = entity.getComponent(PositionComponent);
                const entitySize = entity.getComponent(SizeComponent);
                const entityPhysics = entity.getComponent(PhysicsComponent);

                const distance = playerPhysics.body.position.distanceTo(
                  entityPhysics.body.position
                );
                const collisionDistance = playerSize.size + entitySize.size;

                if (distance < collisionDistance) {
                  if (playerSize.size > entitySize.size * 1.1) {
                    const sizeIncrease = Math.min(
                      entitySize.size * 0.01,
                      playerSize.size * 0.01
                    );
                    playerSize.size += sizeIncrease;

                    this.world.updateEntityVisual(player);
                    this.world.createAbsorptionEffect(entity);
                    this.world.removeEntity(entity);
                    this.world.score += Math.floor(entitySize.size * 10);

                    this.world.camera.position.z = Math.max(
                      100 + playerSize.size * 10,
                      playerSize.size * 10
                    );

                    const currentStageIndex = playerEvolution.stages.indexOf(
                      playerEvolution.stage
                    );
                    const nextStageIndex = currentStageIndex + 1;
                    if (nextStageIndex < playerEvolution.stages.length) {
                      const nextStageThreshold =
                        EvolutionSystem.getStageThreshold(
                          playerEvolution.stages[nextStageIndex]
                        );
                      if (playerSize.size >= nextStageThreshold) {
                        playerEvolution.stage =
                          playerEvolution.stages[nextStageIndex];
                        this.world.updateEntityVisual(player);
                        this.world.createEvolutionEffect(player);
                      }
                    }

                    this.world.updateHUD();
                    this.world.playSound('absorb');
                  } else if (
                    entitySize.size > playerSize.size * 1.1 &&
                    !playerControl.abilities.shield.active
                  ) {
                    this.world.createAbsorptionEffect(player);
                    this.world.gameOver();
                  }
                }
              }

              if (entity.hasComponent(PowerUpComponent)) {
                const entityPosition = entity.getComponent(PositionComponent);
                const entityPhysics = entity.getComponent(PhysicsComponent);

                const distance = playerPhysics.body.position.distanceTo(
                  entityPhysics.body.position
                );

                if (distance < playerSize.size + 5) {
                  const powerUp = entity.getComponent(PowerUpComponent);
                  this.world.applyPowerUp(powerUp.type);
                  this.world.removeEntity(entity);
                  this.world.playSound('powerup');
                }
              }

              if (entity.hasComponent(ObstacleComponent)) {
                const entityPosition = entity.getComponent(PositionComponent);
                const entitySize = entity.getComponent(SizeComponent);
                const entityPhysics = entity.getComponent(PhysicsComponent);

                const distance = playerPhysics.body.position.distanceTo(
                  entityPhysics.body.position
                );

                if (distance < playerSize.size + entitySize.size) {
                  const obstacle = entity.getComponent(ObstacleComponent);
                  if (!playerControl.abilities.shield.active) {
                    switch (obstacle.type) {
                      case 'blackhole':
                        this.world.gameOver();
                        break;
                      case 'asteroid':
                        playerSize.size *= 0.95;
                        this.world.updateEntityVisual(player);
                        this.world.removeEntity(entity);
                        this.world.playSound('collision');
                        break;
                      case 'nebula':
                        playerPhysics.body.velocity.scale(
                          0.5,
                          playerPhysics.body.velocity
                        );
                        break;
                    }
                  }
                }
              }
            }
          }
        }

        class AISystem extends System {
          update(deltaTime) {
            const player = this.world.entities.find((e) =>
              e.hasComponent(PlayerControlledComponent)
            );
            if (!player) return;

            const playerPosition = player.getComponent(PositionComponent);
            const playerSize = player.getComponent(SizeComponent).size;

            for (let entity of this.world.entities) {
              if (
                entity.hasComponent(AIControlledComponent) &&
                entity.hasComponent(PhysicsComponent)
              ) {
                const aiPosition = entity.getComponent(PositionComponent);
                const aiSize = entity.getComponent(SizeComponent).size;
                const aiPhysics = entity.getComponent(PhysicsComponent);
                const aiEvolution = entity.getComponent(
                  EvolutionaryStageComponent
                );

                const currentStageIndex = aiEvolution.stages.indexOf(
                  aiEvolution.stage
                );
                const nextStageIndex = currentStageIndex + 1;
                if (nextStageIndex < aiEvolution.stages.length) {
                  const nextStageThreshold = EvolutionSystem.getStageThreshold(
                    aiEvolution.stages[nextStageIndex]
                  );
                  if (aiSize >= nextStageThreshold) {
                    aiEvolution.stage = aiEvolution.stages[nextStageIndex];
                    this.world.updateEntityVisual(entity);
                  }
                }

                const directionToPlayer = new CANNON.Vec3(
                  playerPosition.x - aiPosition.x,
                  playerPosition.y - aiPosition.y,
                  playerPosition.z - aiPosition.z
                );

                const distanceToPlayer = directionToPlayer.length();
                directionToPlayer.normalize();

                let behavior;
                if (aiSize > playerSize * 1.1) {
                  behavior = 'chase';
                } else if (aiSize < playerSize * 0.9) {
                  behavior = 'flee';
                } else {
                  behavior = 'wander';
                }

                let force = new CANNON.Vec3();
                const maxForce = 5000 / (aiSize * aiSize);

                switch (behavior) {
                  case 'chase':
                    force = directionToPlayer.scale(maxForce);
                    break;
                  case 'flee':
                    force = directionToPlayer.scale(-maxForce);
                    break;
                  case 'wander':
                    force.x = (Math.random() - 0.5) * maxForce;
                    force.y = (Math.random() - 0.5) * maxForce;
                    force.z = 0;
                    break;
                }

                force.x += (Math.random() - 0.5) * maxForce * 0.2;
                force.y += (Math.random() - 0.5) * maxForce * 0.2;
                aiPhysics.body.applyForce(force, aiPhysics.body.position);

                aiPhysics.body.velocity.scale(0.98, aiPhysics.body.velocity);

                const renderComponent = entity.getComponent(RenderComponent);
                if (renderComponent) {
                  const material = renderComponent.mesh.material;
                  if (material.uniforms && material.uniforms.time) {
                    material.uniforms.time.value += deltaTime;
                  }
                }
              }
            }
          }
        }

        class EvolutionaryStageComponent extends Component {
          constructor() {
            super();
            this.stages = [
              'asteroid',
              'moon',
              'planet',
              'star',
              'neutron star',
              'black hole',
            ];
            this.stage = this.stages[0];
            this.progress = 0;
          }
        }

        class EvolutionSystem extends System {
          static getStageThreshold(stage) {
            switch (stage) {
              case 'asteroid':
                return 0;
              case 'moon':
                return 15;
              case 'planet':
                return 150;
              case 'star':
                return 300;
              case 'neutron star':
                return 500;
              case 'black hole':
                return 750;
              default:
                return Infinity;
            }
          }

          update(deltaTime) {
            for (let entity of this.world.entities) {
              if (
                entity.hasComponent(EvolutionaryStageComponent) &&
                entity.hasComponent(SizeComponent)
              ) {
                const evolution = entity.getComponent(
                  EvolutionaryStageComponent
                );
                const size = entity.getComponent(SizeComponent);

                const currentStageIndex = evolution.stages.indexOf(
                  evolution.stage
                );
                const nextStageIndex = currentStageIndex + 1;

                if (nextStageIndex < evolution.stages.length) {
                  const nextStageThreshold = EvolutionSystem.getStageThreshold(
                    evolution.stages[nextStageIndex]
                  );
                  if (size.size >= nextStageThreshold) {
                    evolution.stage = evolution.stages[nextStageIndex];
                    this.world.updateEntityVisual(entity);
                    if (entity.hasComponent(PlayerControlledComponent)) {
                      this.world.createEvolutionEffect(entity);
                    }
                  }
                }

                if (entity.hasComponent(PlayerControlledComponent)) {
                  this.world.updateHUD();
                }
              }
            }
          }
        }
        class GravitySystem extends System {
          update(deltaTime) {
            const gravityEntities = this.world.entities.filter((e) =>
              e.hasComponent(GravityFieldComponent)
            );

            for (let entity of this.world.entities) {
              if (entity.hasComponent(PhysicsComponent)) {
                const physics = entity.getComponent(PhysicsComponent);
                const position = entity.getComponent(PositionComponent);

                for (let gravityEntity of gravityEntities) {
                  const gravityField = gravityEntity.getComponent(
                    GravityFieldComponent
                  );
                  const gravityPosition =
                    gravityEntity.getComponent(PositionComponent);

                  const distance = new CANNON.Vec3(
                    gravityPosition.x - position.x,
                    gravityPosition.y - position.y,
                    gravityPosition.z - position.z
                  );

                  const distanceLength = distance.length();

                  if (distanceLength < gravityField.radius) {
                    const forceMagnitude =
                      gravityField.strength / (distanceLength * distanceLength);
                    const force = distance.scale(
                      forceMagnitude / distanceLength
                    );
                    physics.body.applyForce(force, physics.body.position);
                  }
                }
              }
            }
          }
        }

        class WormholeSystem extends System {
          update() {
            const player = this.world.entities.find((e) =>
              e.hasComponent(PlayerControlledComponent)
            );
            if (!player) return;

            const playerPhysics = player.getComponent(PhysicsComponent);

            for (let entity of this.world.entities) {
              if (entity.hasComponent(WormholeComponent)) {
                const wormholePhysics = entity.getComponent(PhysicsComponent);
                const wormholeExit = entity.getComponent(WormholeComponent);

                const distance = playerPhysics.body.position.distanceTo(
                  wormholePhysics.body.position
                );
                if (distance < 10) {
                  playerPhysics.body.position.set(
                    wormholeExit.exitX,
                    wormholeExit.exitY,
                    0
                  );
                  player.getComponent(PositionComponent).x = wormholeExit.exitX;
                  player.getComponent(PositionComponent).y = wormholeExit.exitY;
                  this.world.createWormholeEffect(player);
                }
              }
            }
          }
        }

        class GravityWellSystem extends System {
          update(deltaTime) {
            for (let entity of this.world.entities) {
              if (entity.hasComponent(PhysicsComponent)) {
                const physics = entity.getComponent(PhysicsComponent);
                const position = entity.getComponent(PositionComponent);

                for (let well of this.world.entities) {
                  if (well.hasComponent(GravityWellComponent)) {
                    const wellPosition = well.getComponent(PositionComponent);
                    const wellComponent =
                      well.getComponent(GravityWellComponent);

                    const force = new CANNON.Vec3(
                      wellPosition.x - position.x,
                      wellPosition.y - position.y,
                      0
                    );

                    const distance = force.length();
                    if (distance < wellComponent.radius) {
                      force.normalize();
                      force.scale(
                        wellComponent.strength / (distance * distance),
                        force
                      );
                      physics.body.applyForce(force, physics.body.position);
                    }
                  }
                }
              }
            }
          }
        }

        class SpaceDustSystem extends System {
          update(deltaTime) {
            const player = this.world.entities.find((e) =>
              e.hasComponent(PlayerControlledComponent)
            );
            if (!player) return;

            const playerPosition = player.getComponent(PositionComponent);
            const playerSize = player.getComponent(SizeComponent).size;

            for (let dust of this.world.entities) {
              if (dust.hasComponent(SpaceDustComponent)) {
                const dustPosition = dust.getComponent(PositionComponent);

                const dx = playerPosition.x - dustPosition.x;
                const dy = playerPosition.y - dustPosition.y;
                const dz = playerPosition.z - dustPosition.z;
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

                if (distance < playerSize * 2) {
                  player.getComponent(SizeComponent).size += 0.01;
                  this.world.updateEntityVisual(player);
                  this.world.removeEntity(dust);
                  this.world.createSpaceDustEffect(dustPosition);
                }
              }
            }
          }
        }
        class World {
          constructor() {
            this.entities = [];
            this.systems = [];
            this.score = 0;
            this.level = 1;
            this.gameActive = false;
            this.boundary = 5000;
            this.enemyCount = 500;
            this.minEnemySize = 0.5;
            this.maxEnemySize = 10;
            this.backgroundParticles = [];
            this.hashinalData = [];
            this.hashinalTextures = new Map();
            this.lastTime = 0;
            this.animationTime = 0;

            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(
              75,
              window.innerWidth / window.innerHeight,
              0.1,
              2000
            );

            this.renderer = new THREE.WebGLRenderer({ antialias: true });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            document
              .getElementById('game-container')
              .appendChild(this.renderer.domElement);

            const planeGeometry = new THREE.PlaneGeometry(2000, 2000);
            const planeMaterial = new THREE.MeshBasicMaterial({
              visible: false,
            });
            this.plane = new THREE.Mesh(planeGeometry, planeMaterial);
            this.plane.rotation.x = -Math.PI / 2;
            this.scene.add(this.plane);

            this.camera.position.set(0, 0, 300);
            this.camera.lookAt(0, 0, 0);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            this.scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1, 1);
            this.scene.add(directionalLight);

            this.physicsSystem = new PhysicsSystem(this);
            this.addSystem(this.physicsSystem);

            this.wallMaterial = new CANNON.Material('wallMaterial');
            this.entityMaterial = new CANNON.Material('entityMaterial');
            this.createTextures();
            this.defineShaders();
            this.createStarfield();
            this.createHashgraphBackground();
            this.createBackgroundEffect();
            this.createNebulae();

            this.setupSound();

            this.createBoundaries();
            this.addSystem(new RenderSystem(this));
            this.addSystem(new PlayerControlSystem(this, this.camera));
            this.addSystem(new CollisionSystem(this));
            this.addSystem(new AISystem(this));
            this.addSystem(new EvolutionSystem(this));
            this.addSystem(new GravitySystem(this));
            this.addSystem(new WormholeSystem(this));
            this.addSystem(new GravityWellSystem(this));
            this.addSystem(new SpaceDustSystem(this));

            let hashinalsCompleted = false;

            this.fetchHashinalData().then((a) => {
              hashinalsCompleted = true;
            });

            window.addEventListener('resize', () => this.onWindowResize());
            document
              .getElementById('start-button')
              .addEventListener('click', () => this.startGame());
            document
              .getElementById('restart-button')
              .addEventListener('click', () => this.startGame());

            this.updateHUD();
            this.createVisibleWalls();
          }

          async fetchHashinalData() {
            try {
              const url =
                'https://tier.bot/api/inscriptions/numbers?random=true&limit=200';
              const response = await fetch(url);
              if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
              }
              this.hashinalData = await response.json();
              await this.preloadHashinalTextures();
            } catch (error) {
              console.error('Error fetching Hashinal data:', error);
            }
          }
          async preloadHashinalTextures() {
            const textureLoader = new THREE.TextureLoader();
            const loadTexture = (url) =>
              new Promise((resolve) => textureLoader.load(url, resolve));

            for (const hashinal of this.hashinalData) {
              const texture = await loadTexture(
                `https://tier.bot/api/hashinals-cdn/${hashinal.image}?network=mainnet`
              );
              this.hashinalTextures.set(hashinal.image, texture);
            }
          }
          createBackgroundEffect() {
            const particleCount = 10000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            for (let i = 0; i < particleCount; i++) {
              positions[i * 3] = (Math.random() - 0.5) * this.boundary * 2;
              positions[i * 3 + 1] = (Math.random() - 0.5) * this.boundary * 2;
              positions[i * 3 + 2] = (Math.random() - 0.5) * 1000;

              const color = new THREE.Color();
              color.setHSL(Math.random(), 1, 0.5 + Math.random() * 0.5);
              colors[i * 3] = color.r;
              colors[i * 3 + 1] = color.g;
              colors[i * 3 + 2] = color.b;

              sizes[i] = Math.random() * 2 + 1;
            }

            geometry.setAttribute(
              'position',
              new THREE.BufferAttribute(positions, 3)
            );
            geometry.setAttribute(
              'customColor',
              new THREE.BufferAttribute(colors, 3)
            );
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
              uniforms: {
                time: { value: 0 },
                scale: { value: 1.0 },
              },
              vertexShader: this.shaders.particleVertex,
              fragmentShader: this.shaders.particleFragment,
              blending: THREE.AdditiveBlending,
              depthTest: false,
              transparent: true,
            });

            this.backgroundParticles = new THREE.Points(geometry, material);
            this.scene.add(this.backgroundParticles);
          }
          createNebulae() {
            for (let i = 0; i < 5; i++) {
              const geometry = new THREE.BufferGeometry();
              const positions = new Float32Array(10000 * 3);
              const colors = new Float32Array(10000 * 3);
              const sizes = new Float32Array(10000);

              const centerX = (Math.random() - 0.5) * this.boundary;
              const centerY = (Math.random() - 0.5) * this.boundary;
              const centerZ = (Math.random() - 0.5) * 500;
              const radius = Math.random() * 300 + 100;

              for (let j = 0; j < 10000; j++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI * 2;
                const r = Math.random() * radius;

                positions[j * 3] =
                  centerX + r * Math.sin(phi) * Math.cos(theta);
                positions[j * 3 + 1] =
                  centerY + r * Math.sin(phi) * Math.sin(theta);
                positions[j * 3 + 2] = centerZ + r * Math.cos(phi);

                const color = new THREE.Color();
                color.setHSL(
                  Math.random() * 0.1 + 0.6,
                  1,
                  0.5 + Math.random() * 0.5
                );
                colors[j * 3] = color.r;
                colors[j * 3 + 1] = color.g;
                colors[j * 3 + 2] = color.b;

                sizes[j] = Math.random() * 5 + 2;
              }

              geometry.setAttribute(
                'position',
                new THREE.BufferAttribute(positions, 3)
              );
              geometry.setAttribute(
                'color',
                new THREE.BufferAttribute(colors, 3)
              );
              geometry.setAttribute(
                'size',
                new THREE.BufferAttribute(sizes, 1)
              );

              const material = new THREE.ShaderMaterial({
                uniforms: {
                  time: { value: 0 },
                  scale: { value: 1.0 },
                },
                vertexShader: `
  uniform float time;
  uniform float scale;
  attribute vec3 currentPosition;
  attribute vec3 color; 
  attribute float size;
  varying vec3 vColor;
  void main() {
    vColor = color;
    vec3 pos = currentPosition;
    pos.x += sin(time * 0.5 + currentPosition.z * 0.01) * 2.0;
    pos.y += cos(time * 0.5 + currentPosition.x * 0.01) * 2.0;
    pos.z += sin(time * 0.5 + currentPosition.y * 0.01) * 2.0;
    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
    gl_PointSize = size * scale * (300.0 / -mvPosition.z);
    gl_Position = projectionMatrix * mvPosition;
  }
`,
                fragmentShader: `
          varying vec3 vColor;
          void main() {
            if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.475) discard;
            gl_FragColor = vec4(vColor, 0.7);
          }
        `,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
              });

              const nebula = new THREE.Points(geometry, material);
              this.scene.add(nebula);
            }
          }
          addPulsatingEffect(mesh) {
            const originalScale = mesh.scale.clone();
            const pulsate = () => {
              const scale = 1 + Math.sin(Date.now() * 0.005) * 0.05;
              mesh.scale.copy(originalScale).multiplyScalar(scale);
              requestAnimationFrame(pulsate);
            };
            pulsate();
          }

          createStarfield() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
              color: 0xffffff,
              size: 0.5,
              transparent: true,
              blending: THREE.AdditiveBlending,
            });
            const starsVertices = [];
            for (let i = 0; i < 20000; i++) {
              const x = (Math.random() - 0.5) * this.boundary * 2;
              const y = (Math.random() - 0.5) * this.boundary * 2;
              const z = (Math.random() - 0.5) * 2000;
              starsVertices.push(x, y, z);
            }
            starsGeometry.setAttribute(
              'position',
              new THREE.Float32BufferAttribute(starsVertices, 3)
            );
            const starField = new THREE.Points(starsGeometry, starsMaterial);
            this.scene.add(starField);
          }
          createHashgraphBackground() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];

            for (let i = 0; i < 2000; i++) {
              const x = (Math.random() - 0.5) * this.boundary * 2;
              const y = (Math.random() - 0.5) * this.boundary * 2;
              const z = (Math.random() - 0.5) * 1000;

              vertices.push(x, y, z);

              const color = new THREE.Color();
              color.setHSL(0.6, 1, Math.random() * 0.5 + 0.5);
              colors.push(color.r, color.g, color.b);
            }

            geometry.setAttribute(
              'position',
              new THREE.Float32BufferAttribute(vertices, 3)
            );
            geometry.setAttribute(
              'color',
              new THREE.Float32BufferAttribute(colors, 3)
            );

            const material = new THREE.PointsMaterial({
              size: 5,
              vertexColors: true,
              transparent: true,
              opacity: 0.8,
            });

            const points = new THREE.Points(geometry, material);
            this.scene.add(points);
          }
          setupSound() {}

          createTextures() {
            this.textures = {
              planet: this.createPlanetTexture(),
              planetBump: this.createPlanetBumpMap(),
              star: this.createStarTexture(),
              neutronStar: this.createNeutronStarTexture(),
            };
          }

          createNeutronStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            const gradient = ctx.createRadialGradient(
              256,
              256,
              0,
              256,
              256,
              256
            );
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(0.3, '#00ffff');
            gradient.addColorStop(0.6, '#0080ff');
            gradient.addColorStop(1, '#000080');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);

            for (let i = 0; i < 10; i++) {
              const pulseGradient = ctx.createRadialGradient(
                256,
                256,
                0,
                256,
                256,
                256 * Math.random()
              );
              pulseGradient.addColorStop(0, 'rgba(255, 255, 255, 0.5)');
              pulseGradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
              ctx.fillStyle = pulseGradient;
              ctx.fillRect(0, 0, 512, 512);
            }

            ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 8; i++) {
              ctx.beginPath();
              ctx.moveTo(0, i * 64);
              ctx.bezierCurveTo(
                128,
                i * 64 + 32,
                384,
                i * 64 - 32,
                512,
                i * 64
              );
              ctx.stroke();
            }

            return new THREE.CanvasTexture(canvas);
          }

          createPlanetTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            const gradient = ctx.createRadialGradient(
              256,
              256,
              0,
              256,
              256,
              256
            );
            gradient.addColorStop(0, '#4287f5');
            gradient.addColorStop(1, '#1a3c6e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);

            ctx.fillStyle = '#2ecc71';
            for (let i = 0; i < 10; i++) {
              ctx.beginPath();
              ctx.moveTo(Math.random() * 512, Math.random() * 512);
              ctx.bezierCurveTo(
                Math.random() * 512,
                Math.random() * 512,
                Math.random() * 512,
                Math.random() * 512,
                Math.random() * 512,
                Math.random() * 512
              );
              ctx.fill();
            }

            return new THREE.CanvasTexture(canvas);
          }

          createPlanetBumpMap() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, 512, 512);

            for (let i = 0; i < 1000; i++) {
              const x = Math.random() * 512;
              const y = Math.random() * 512;
              const radius = Math.random() * 5 + 1;
              const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
              gradient.addColorStop(0, 'white');
              gradient.addColorStop(1, 'black');
              ctx.fillStyle = gradient;
              ctx.beginPath();
              ctx.arc(x, y, radius, 0, Math.PI * 2);
              ctx.fill();
            }

            return new THREE.CanvasTexture(canvas);
          }

          createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            const gradient = ctx.createRadialGradient(
              256,
              256,
              0,
              256,
              256,
              256
            );
            gradient.addColorStop(0, 'white');
            gradient.addColorStop(0.1, 'yellow');
            gradient.addColorStop(0.3, 'orange');
            gradient.addColorStop(0.6, 'red');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);

            for (let i = 0; i < 8; i++) {
              ctx.save();
              ctx.translate(256, 256);
              ctx.rotate((i * Math.PI) / 4);
              ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
              ctx.beginPath();
              ctx.moveTo(0, 0);
              ctx.lineTo(200, 0);
              ctx.lineTo(0, 20);
              ctx.closePath();
              ctx.fill();
              ctx.restore();
            }

            return new THREE.CanvasTexture(canvas);
          }

          defineShaders() {
            this.shaders = {
              blackholeVertex: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
              blackholeFragment: `
                uniform float time;
                varying vec2 vUv;
                void main() {
                    vec2 center = vec2(0.5, 0.5);
                    float dist = distance(vUv, center);
                    float color = smoothstep(0.5, 0.2, dist);
                    gl_FragColor = vec4(color, color, color, 1.0);
                }
            `,
              glowVertex: `
                uniform vec3 viewVector;
                varying float intensity;
                void main() {
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    vec3 actual_normal = vec3(modelMatrix * vec4(normal, 0.0));
                    intensity = pow(dot(normalize(viewVector), actual_normal), 6.0);
                }
            `,
              glowFragment: `
                uniform vec3 glowColor;
                varying float intensity;
                void main() {
                    gl_FragColor = vec4(glowColor, 1.0) * intensity;
                }
            `,
              accretionDiskVertex: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
              accretionDiskFragment: `
                uniform float time;
                varying vec2 vUv;
                void main() {
                    float r = length(vUv - vec2(0.5));
                    float theta = atan(vUv.y - 0.5, vUv.x - 0.5);
                    float color = sin(50.0 * r - 10.0 * time) * 0.5 + 0.5;
                    gl_FragColor = vec4(color, color * 0.5, 0.0, 1.0);
                }
            `,
              particleVertex: `
    attribute float size;
    attribute vec3 color;
    varying vec3 vColor;
    varying float vAlpha;
    
    void main() {
      vColor = color;
      vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
      gl_PointSize = size * (300.0 / -mvPosition.z);
      gl_Position = projectionMatrix * mvPosition;
      vAlpha = smoothstep(200.0, 100.0, -mvPosition.z);
    }
  `,
              particleFragment: `
    varying vec3 vColor;
    varying float vAlpha;
    
    void main() {
      float r = 0.0, delta = 0.0, alpha = 1.0;
      vec2 cxy = 2.0 * gl_PointCoord - 1.0;
      r = dot(cxy, cxy);
      if (r > 1.0) {
          discard;
      }
      delta = fwidth(r);
      alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);
      
      vec3 glow = vColor * (1.0 - r * r);
      gl_FragColor = vec4(glow, alpha * vAlpha);
    }
  `,
              spaceDustVertex: `
    attribute float size;
    varying float vAlpha;
    
    void main() {
      vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
      gl_PointSize = size * (300.0 / -mvPosition.z);
      gl_Position = projectionMatrix * mvPosition;
      vAlpha = smoothstep(200.0, 100.0, -mvPosition.z);
    }
  `,
              spaceDustFragment: `
    varying float vAlpha;
    
    void main() {
      float r = 0.0, delta = 0.0, alpha = 1.0;
      vec2 cxy = 2.0 * gl_PointCoord - 1.0;
      r = dot(cxy, cxy);
      if (r > 1.0) {
        discard;
      }
      delta = fwidth(r);
      alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);
      
      vec3 color = vec3(0.9, 0.9, 1.0);  
      vec3 glow = color * (1.0 - r * r);
      gl_FragColor = vec4(glow, alpha * vAlpha);
    }
  `,
              moonFragment: `
    uniform sampler2D bumpMap;
    uniform float bumpScale;
    varying vec2 vUv;
    varying vec3 vNormal;

    void main() {
        vec4 bumpData = texture2D(bumpMap, vUv);
        vec3 normal = normalize(vNormal + bumpScale * bumpData.rgb);
        vec3 light = vec3(0.5, 0.5, 1.0);
        float lighting = dot(normal, light);
        gl_FragColor = vec4(vec3(lighting), 1.0);
    }
`,
              moonVertex: `
    varying vec2 vUv;
    varying vec3 vNormal;

    void main() {
        vUv = uv;
        vNormal = normalize(normalMatrix * normal);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
`,
            };
          }

          createBoundaries() {
            const wallThickness = 50;

            const createWall = (positionX, positionY, sizeX, sizeY) => {
              const wallShape = new CANNON.Box(
                new CANNON.Vec3(sizeX, sizeY, wallThickness)
              );
              const wallBody = new CANNON.Body({
                mass: 0,
                shape: wallShape,
                material: this.wallMaterial,
              });
              wallBody.position.set(positionX, positionY, 0);
              this.physicsSystem.physicsWorld.addBody(wallBody);
            };

            createWall(
              this.boundary,
              0,
              wallThickness,
              this.boundary + wallThickness
            );
            createWall(
              -this.boundary,
              0,
              wallThickness,
              this.boundary + wallThickness
            );
            createWall(
              0,
              this.boundary,
              this.boundary + wallThickness,
              wallThickness
            );
            createWall(
              0,
              -this.boundary,
              this.boundary + wallThickness,
              wallThickness
            );

            const wallEntityContactMaterial = new CANNON.ContactMaterial(
              this.wallMaterial,
              this.entityMaterial,
              { friction: 0.0, restitution: 0.7 }
            );

            this.physicsSystem.physicsWorld.addContactMaterial(
              wallEntityContactMaterial
            );
          }

          createVisibleWalls() {
            const wallThickness = 50;
            const wallHeight = 300;
            const wallMaterial = new THREE.MeshBasicMaterial({
              color: 0x808080,
              transparent: true,
              opacity: 0.5,
            });

            const createWall = (positionX, positionY, sizeX, sizeY) => {
              const wallGeometry = new THREE.BoxGeometry(
                sizeX * 2,
                sizeY * 2,
                wallHeight
              );
              const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
              wallMesh.position.set(positionX, positionY, wallHeight / 2);
              this.scene.add(wallMesh);
            };

            createWall(
              this.boundary,
              0,
              wallThickness,
              this.boundary + wallThickness
            );
            createWall(
              -this.boundary,
              0,
              wallThickness,
              this.boundary + wallThickness
            );
            createWall(
              0,
              this.boundary,
              this.boundary + wallThickness,
              wallThickness
            );
            createWall(
              0,
              -this.boundary,
              this.boundary + wallThickness,
              wallThickness
            );
          }

          createWormhole() {
            const wormhole = new Entity();
            const x1 = (Math.random() - 0.5) * this.boundary * 1.8;
            const y1 = (Math.random() - 0.5) * this.boundary * 1.8;
            const x2 = (Math.random() - 0.5) * this.boundary * 1.8;
            const y2 = (Math.random() - 0.5) * this.boundary * 1.8;

            wormhole.addComponent(new PositionComponent(x1, y1, 0));
            wormhole.addComponent(new WormholeComponent(x2, y2));

            const geometry = new THREE.TorusGeometry(10, 3, 16, 100);
            const material = new THREE.MeshPhongMaterial({
              color: 0x9900ff,
              emissive: 0x9900ff,
              emissiveIntensity: 0.5,
            });
            const mesh = new THREE.Mesh(geometry, material);
            wormhole.addComponent(new RenderComponent(mesh));

            const shape = new CANNON.Sphere(10);
            const body = new CANNON.Body({
              mass: 0,
              shape: shape,
              position: new CANNON.Vec3(x1, y1, 0),
            });
            wormhole.addComponent(new PhysicsComponent(body));

            this.scene.add(mesh);
            this.physicsSystem.physicsWorld.addBody(body);
            this.addEntity(wormhole);
          }
          createGravityWell() {
            const gravityWell = new Entity();
            const x = (Math.random() - 0.5) * this.boundary * 1.8;
            const y = (Math.random() - 0.5) * this.boundary * 1.8;

            gravityWell.addComponent(new PositionComponent(x, y, 0));
            gravityWell.addComponent(new GravityWellComponent(100, 500));

            const geometry = new THREE.SphereGeometry(5, 32, 32);
            const material = new THREE.MeshPhongMaterial({
              color: 0x00ffff,
              transparent: true,
              opacity: 0.7,
            });
            const mesh = new THREE.Mesh(geometry, material);
            gravityWell.addComponent(new RenderComponent(mesh));

            this.scene.add(mesh);
            this.addEntity(gravityWell);
          }

          createSpaceDust() {
            for (let i = 0; i < 1000; i++) {
              const dust = new Entity();
              const x = (Math.random() - 0.5) * this.boundary * 2;
              const y = (Math.random() - 0.5) * this.boundary * 2;
              dust.addComponent(new PositionComponent(x, y, 0));
              dust.addComponent(new SpaceDustComponent());
              dust.addComponent(new SizeComponent(0.1));

              const geometry = new THREE.SphereGeometry(0.1, 8, 8);
              const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
              const mesh = new THREE.Mesh(geometry, material);
              dust.addComponent(new RenderComponent(mesh));

              this.scene.add(mesh);
              this.addEntity(dust);
            }
          }

          addEntity(entity) {
            this.entities.push(entity);
          }

          removeEntity(entity) {
            const index = this.entities.indexOf(entity);
            if (index !== -1) {
              this.entities.splice(index, 1);
              if (entity.hasComponent(RenderComponent)) {
                const renderComponent = entity.getComponent(RenderComponent);
                this.scene.remove(renderComponent.mesh);
              }
              if (entity.hasComponent(PhysicsComponent)) {
                const physicsComponent = entity.getComponent(PhysicsComponent);
                this.physicsSystem.physicsWorld.removeBody(
                  physicsComponent.body
                );
              }
            }
          }

          addSystem(system) {
            this.systems.push(system);
          }

          update(deltaTime) {
            for (let system of this.systems) {
              system.update(deltaTime);
            }

            for (let entity of this.entities) {
              if (
                entity.hasComponent(PositionComponent) &&
                entity.hasComponent(PhysicsComponent) &&
                entity.hasComponent(SizeComponent)
              ) {
                const position = entity.getComponent(PositionComponent);
                const physics = entity.getComponent(PhysicsComponent);
                const size = entity.getComponent(SizeComponent);

                const maxX = this.boundary - size.size;
                const maxY = this.boundary - size.size;

                if (Math.abs(position.x) > maxX) {
                  position.x = Math.sign(position.x) * maxX;
                  physics.body.position.x = position.x;
                  physics.body.velocity.x = -physics.body.velocity.x * 0.8;
                }

                if (Math.abs(position.y) > maxY) {
                  position.y = Math.sign(position.y) * maxY;
                  physics.body.position.y = position.y;
                  physics.body.velocity.y = -physics.body.velocity.y * 0.8;
                }

                physics.body.position.set(position.x, position.y, position.z);
              }
            }
          }

          createPlayer() {
            const player = new Entity();
            const initialSize = 10;
            player.addComponent(new PositionComponent(0, 0, 0));
            player.addComponent(new SizeComponent(initialSize));
            player.addComponent(new PlayerControlledComponent());
            const evolutionComponent = new EvolutionaryStageComponent();
            player.addComponent(evolutionComponent);

            const mesh = this.createEntityMesh(
              evolutionComponent.stage,
              initialSize
            );
            player.addComponent(new RenderComponent(mesh));

            const shape = new CANNON.Sphere(initialSize);
            const body = new CANNON.Body({
              mass: 5,
              shape: shape,
              material: this.entityMaterial,
              position: new CANNON.Vec3(0, 0, 0),
              velocity: new CANNON.Vec3(0, 0, 0),
            });
            player.addComponent(new PhysicsComponent(body));

            this.scene.add(mesh);
            this.physicsSystem.physicsWorld.addBody(body);
            this.addEntity(player);

            return player;
          }
          createEntityMesh(stage, size) {
            let geometry, material;
            const scaledSize = Math.max(size * 0.5, 1);

            switch (stage) {
              case 'asteroid':
                geometry = new THREE.IcosahedronGeometry(scaledSize, 0);
                material = new THREE.MeshStandardMaterial({
                  color: 0x8b4513,
                  roughness: 0.8,
                  metalness: 0.2,
                });
                break;
              case 'moon':
                if (Math.random() < 0.5 && this.hashinalTextures.size > 0) {
                  const randomTexture = Array.from(
                    this.hashinalTextures.values()
                  )[Math.floor(Math.random() * this.hashinalTextures.size)];
                  material = new THREE.ShaderMaterial({
                    map: randomTexture,
                    uniforms: {
                      bumpMap: { value: this.textures.planetBump },
                      bumpScale: { value: 0.02 },
                    },
                    vertexShader: this.shaders.moonVertex,
                    fragmentShader: this.shaders.moonFragment,
                  });
                } else {
                  geometry = new THREE.SphereGeometry(scaledSize, 32, 32);
                  material = new THREE.ShaderMaterial({
                    uniforms: {
                      bumpMap: { value: this.textures.planetBump },
                      bumpScale: { value: 0.02 },
                    },
                    vertexShader: this.shaders.moonVertex,
                    fragmentShader: this.shaders.moonFragment,
                  });
                }
                break;
              case 'planet':
              case 'hashinal':
                geometry = new THREE.SphereGeometry(scaledSize, 32, 32);
                if (Math.random() < 0.5 && this.hashinalTextures.size > 0) {
                  const randomTexture = Array.from(
                    this.hashinalTextures.values()
                  )[Math.floor(Math.random() * this.hashinalTextures.size)];
                  material = new THREE.MeshPhongMaterial({
                    map: randomTexture,
                    bumpMap: this.textures.planetBump,
                    bumpScale: 0.05,
                  });
                } else {
                  material = new THREE.MeshPhongMaterial({
                    map: this.textures.planet,
                    bumpMap: this.textures.planetBump,
                    bumpScale: 0.05,
                  });
                }
                break;
              case 'star':
                geometry = new THREE.SphereGeometry(scaledSize, 32, 32);
                material = new THREE.MeshBasicMaterial({
                  map: this.textures.star,
                  emissive: 0xffff00,
                  emissiveIntensity: 0.5,
                });
                break;
              case 'neutron star':
                geometry = new THREE.SphereGeometry(scaledSize, 32, 32);
                material = new THREE.MeshPhongMaterial({
                  map: this.textures.neutronStar,
                  emissive: 0x00ffff,
                  emissiveIntensity: 0.8,
                  shininess: 100,
                });
                break;
              case 'black hole':
                geometry = new THREE.SphereGeometry(scaledSize, 32, 32);
                material = new THREE.ShaderMaterial({
                  uniforms: {
                    time: { value: 0 },
                  },
                  vertexShader: this.shaders.blackholeVertex,
                  fragmentShader: this.shaders.blackholeFragment,
                });
                break;
              default:
                geometry = new THREE.SphereGeometry(scaledSize, 32, 32);
                material = new THREE.MeshStandardMaterial({
                  color: 0xffffff,
                });
            }

            const mesh = new THREE.Mesh(geometry, material);
            if (Math.random() < 0.2 && this.hashinalTextures.size > 0) {
              const randomTexture = Array.from(this.hashinalTextures.values())[
                Math.floor(Math.random() * this.hashinalTextures.size)
              ];
              const hashinalGeometry = new THREE.PlaneGeometry(
                scaledSize * 2,
                scaledSize * 2
              );
              const hashinalMaterial = new THREE.MeshBasicMaterial({
                map: randomTexture,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide,
              });
              const hashinalMesh = new THREE.Mesh(
                hashinalGeometry,
                hashinalMaterial
              );
              hashinalMesh.rotation.x = Math.PI / 2;
              mesh.add(hashinalMesh);
            }
            return mesh;
          }
          getInitialStage(size) {
            if (size < 2) return 'asteroid';
            if (size < 4) return 'moon';
            if (size < 6) return Math.random() < 0.5 ? 'planet' : 'hashinal';
            if (size < 8) return 'star';
            if (size < 10) return 'neutron star';
            return 'black hole';
          }

          createAIEntity() {
            const entity = new Entity();
            const x = (Math.random() - 0.5) * this.boundary * 1.8;
            const y = (Math.random() - 0.5) * this.boundary * 1.8;
            entity.addComponent(new PositionComponent(x, y, 0));

            const size =
              Math.random() * (this.maxEnemySize - this.minEnemySize) +
              this.minEnemySize;
            entity.addComponent(new SizeComponent(size));
            entity.addComponent(new AIControlledComponent());
            entity.addComponent(new AbsorbableComponent());

            const evolutionComponent = new EvolutionaryStageComponent();
            const initialStage = this.getInitialStage(size);
            evolutionComponent.stage = initialStage;
            entity.addComponent(evolutionComponent);

            const mesh = this.createEntityMesh(initialStage, size);
            entity.addComponent(new RenderComponent(mesh));

            const shape = new CANNON.Sphere(size);
            const body = new CANNON.Body({
              mass: size,
              shape: shape,
              material: this.entityMaterial,
              position: new CANNON.Vec3(x, y, 0),
              velocity: new CANNON.Vec3(
                (Math.random() - 0.5) * 10,
                (Math.random() - 0.5) * 10,
                0
              ),
            });
            entity.addComponent(new PhysicsComponent(body));

            this.scene.add(mesh);
            this.physicsSystem.physicsWorld.addBody(body);
            this.addEntity(entity);

            this.addPulsatingEffect(mesh);

            return entity;
          }
          createHashinalMesh(size) {
            const hashinal =
              this.hashinalData[
                Math.floor(Math.random() * this.hashinalData.length)
              ];
            const texture = this.hashinalTextures.get(hashinal.image);

            const geometry = new THREE.PlaneGeometry(size, size);
            const material = new THREE.MeshBasicMaterial({
              map: texture,
              transparent: true,
              side: THREE.DoubleSide,
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.userData.hashinalData = hashinal;

            return mesh;
          }

          createPowerUp() {
            const powerUpTypes = ['speed', 'size', 'shield', 'boost'];
            const type =
              powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];

            const entity = new Entity();
            const x = (Math.random() - 0.5) * this.boundary * 2;
            const y = (Math.random() - 0.5) * this.boundary * 2;
            entity.addComponent(new PositionComponent(x, y, 0));
            entity.addComponent(new PowerUpComponent(type));

            let color;
            switch (type) {
              case 'speed':
                color = 0xffff00;
                break;
              case 'size':
                color = 0xff00ff;
                break;
              case 'shield':
                color = 0x0000ff;
                break;
              case 'boost':
                color = 0xff0000;
                break;
            }

            const geometry = new THREE.OctahedronGeometry(2.5);
            const material = new THREE.MeshPhongMaterial({
              color: color,
              emissive: color,
              emissiveIntensity: 0.5,
              shininess: 100,
            });
            const mesh = new THREE.Mesh(geometry, material);
            entity.addComponent(new RenderComponent(mesh));

            const shape = new CANNON.Sphere(2.5);
            const body = new CANNON.Body({
              mass: 0,
              shape: shape,
              position: new CANNON.Vec3(x, y, 0),
            });
            entity.addComponent(new PhysicsComponent(body));

            this.scene.add(mesh);
            this.physicsSystem.physicsWorld.addBody(body);
            this.addEntity(entity);
          }

          createObstacle() {
            const obstacleTypes = ['blackhole', 'asteroid', 'nebula'];
            const type =
              obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];

            const entity = new Entity();
            const x = (Math.random() - 0.5) * this.boundary * 2;
            const y = (Math.random() - 0.5) * this.boundary * 2;
            entity.addComponent(new PositionComponent(x, y, 0));
            entity.addComponent(new ObstacleComponent(type));

            let geometry, material, shape, mass;
            switch (type) {
              case 'blackhole':
                geometry = new THREE.SphereGeometry(10, 32, 32);
                material = new THREE.MeshBasicMaterial({ color: 0x000000 });
                shape = new CANNON.Sphere(10);
                mass = 0;
                entity.addComponent(new GravityFieldComponent(500, 100));
                break;
              case 'asteroid':
                geometry = new THREE.DodecahedronGeometry(5);
                material = new THREE.MeshPhongMaterial({ color: 0x808080 });
                shape = new CANNON.Box(new CANNON.Vec3(5, 5, 5));
                mass = 100;
                break;
              case 'nebula':
                geometry = new THREE.SphereGeometry(20, 32, 32);
                material = new THREE.MeshPhongMaterial({
                  color: 0x4b0082,
                  transparent: true,
                  opacity: 0.5,
                });
                shape = new CANNON.Sphere(20);
                mass = 0;
                break;
            }

            const mesh = new THREE.Mesh(geometry, material);
            entity.addComponent(new RenderComponent(mesh));
            entity.addComponent(
              new SizeComponent(mesh.geometry.parameters.radius)
            );

            const body = new CANNON.Body({
              mass: mass,
              shape: shape,
              position: new CANNON.Vec3(x, y, 0),
            });
            entity.addComponent(new PhysicsComponent(body));

            this.scene.add(mesh);
            this.physicsSystem.physicsWorld.addBody(body);
            this.addEntity(entity);
          }

          applyPowerUp(type) {
            const player = this.entities.find((e) =>
              e.hasComponent(PlayerControlledComponent)
            );
            if (!player) return;

            const playerControl = player.getComponent(
              PlayerControlledComponent
            );

            switch (type) {
              case 'speed':
                playerControl.abilities.boost.active = true;
                setTimeout(() => {
                  playerControl.abilities.boost.active = false;
                }, 5000);
                break;
              case 'size':
                const size = player.getComponent(SizeComponent);
                size.size *= 1.2;
                this.updateEntityVisual(player);
                break;
              case 'shield':
                this.activateShield(player);
                break;
              case 'boost':
                this.activateBoost(player);
                break;
            }
          }

          activateShield(player) {
            const playerControl = player.getComponent(
              PlayerControlledComponent
            );
            playerControl.abilities.shield.active = true;

            const shieldGeometry = new THREE.SphereGeometry(
              player.getComponent(SizeComponent).size * 1.2,
              32,
              32
            );
            const shieldMaterial = new THREE.MeshPhongMaterial({
              color: 0x0000ff,
              transparent: true,
              opacity: 0.3,
            });
            const shieldMesh = new THREE.Mesh(shieldGeometry, shieldMaterial);
            player.getComponent(RenderComponent).mesh.add(shieldMesh);

            setTimeout(() => {
              playerControl.abilities.shield.active = false;
              player.getComponent(RenderComponent).mesh.remove(shieldMesh);
            }, 10000);
          }

          activateBoost(player) {
            const playerControl = player.getComponent(
              PlayerControlledComponent
            );
            playerControl.abilities.boost.active = true;

            setTimeout(() => {
              playerControl.abilities.boost.active = false;
            }, 5000);
          }

          createGravitationalPulse(player) {
            const playerPosition = player.getComponent(PositionComponent);
            const playerSize = player.getComponent(SizeComponent);

            const pulseGeometry = new THREE.SphereGeometry(
              playerSize.size * 5,
              32,
              32
            );
            const pulseMaterial = new THREE.MeshBasicMaterial({
              color: 0x00ff00,
              transparent: true,
              opacity: 0.3,
            });
            const pulseMesh = new THREE.Mesh(pulseGeometry, pulseMaterial);
            pulseMesh.position.set(
              playerPosition.x,
              playerPosition.y,
              playerPosition.z
            );

            this.scene.add(pulseMesh);

            const pulseAnimation = createjs.Tween.get(pulseMesh.scale)
              .to({ x: 2, y: 2, z: 2 }, 1000, createjs.Ease.quadOut)
              .call(() => {
                this.scene.remove(pulseMesh);
              });

            pulseAnimation.start();

            for (let entity of this.entities) {
              if (entity !== player && entity.hasComponent(PhysicsComponent)) {
                const entityPosition = entity.getComponent(PositionComponent);
                const physics = entity.getComponent(PhysicsComponent);

                const distance = new THREE.Vector3(
                  playerPosition.x,
                  playerPosition.y,
                  playerPosition.z
                ).distanceTo(
                  new THREE.Vector3(
                    entityPosition.x,
                    entityPosition.y,
                    entityPosition.z
                  )
                );

                if (distance < playerSize.size * 5) {
                  const force = (1 - distance / (playerSize.size * 5)) * 500;
                  const direction = new CANNON.Vec3(
                    entityPosition.x - playerPosition.x,
                    entityPosition.y - playerPosition.y,
                    entityPosition.z - playerPosition.z
                  ).unit();

                  physics.body.applyForce(direction.scale(force));
                }
              }
            }
          }

          updateEntityVisual(entity) {
            const renderComponent = entity.getComponent(RenderComponent);
            if (!renderComponent) return;

            const mesh = renderComponent.mesh;
            const evolution = entity.getComponent(EvolutionaryStageComponent);
            const size = entity.getComponent(SizeComponent).size;

            this.scene.remove(mesh);

            const newMesh = this.createEntityMesh(evolution.stage, size);

            renderComponent.mesh = newMesh;

            this.scene.add(newMesh);

            const physicsComponent = entity.getComponent(PhysicsComponent);
            if (physicsComponent) {
              const shape = new CANNON.Sphere(size);
              physicsComponent.body.shapes[0] = shape;
              physicsComponent.body.updateBoundingRadius();
            }

            if (entity.hasComponent(AIControlledComponent)) {
              this.addPulsatingEffect(newMesh);
            }
          }
          addStarGlow(starMesh) {
            const glowMaterial = new THREE.ShaderMaterial({
              uniforms: {
                c: { type: 'f', value: 0.1 },
                p: { type: 'f', value: 1.2 },
                glowColor: { type: 'c', value: new THREE.Color(0xffff00) },
                viewVector: { type: 'v3', value: this.camera.position },
              },
              vertexShader: this.shaders.glowVertex,
              fragmentShader: this.shaders.glowFragment,
              side: THREE.BackSide,
              blending: THREE.AdditiveBlending,
              transparent: true,
            });

            const glowMesh = new THREE.Mesh(
              starMesh.geometry.clone(),
              glowMaterial
            );
            glowMesh.scale.multiplyScalar(1.2);
            starMesh.add(glowMesh);
          }

          addAccretionDisk(blackholeMesh) {
            const diskGeometry = new THREE.RingGeometry(2, 5, 64);
            const diskMaterial = new THREE.ShaderMaterial({
              uniforms: {
                time: { value: 0 },
              },
              vertexShader: this.shaders.accretionDiskVertex,
              fragmentShader: this.shaders.accretionDiskFragment,
              side: THREE.DoubleSide,
              transparent: true,
            });
            const accretionDisk = new THREE.Mesh(diskGeometry, diskMaterial);
            accretionDisk.rotation.x = Math.PI / 2;
            blackholeMesh.add(accretionDisk);
          }

          startGame() {
            while (this.entities.length > 0) {
              this.removeEntity(this.entities[0]);
            }

            this.score = 0;
            this.level = 1;

            this.createPlayer();

            for (let i = 0; i < this.enemyCount; i++) {
              this.createAIEntity();
            }

            for (let i = 0; i < 20; i++) {
              this.createObstacle();
            }

            this.createSpaceDust();
            this.createWormhole();
            this.createGravityWell();

            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('hud').style.display = 'block';

            this.gameActive = true;
          }
          gameOver() {
            this.gameActive = false;
            document.getElementById('game-over-screen').style.display = 'block';
            document.getElementById('final-score').textContent = this.score;
            document.getElementById('final-level').textContent = this.level;
          }

          updateHUD() {
            document.getElementById(
              'score'
            ).textContent = `Score: ${this.score}`;
            document.getElementById(
              'level'
            ).textContent = `Level: ${this.level}`;
            const player = this.entities.find((e) =>
              e.hasComponent(PlayerControlledComponent)
            );
            if (player) {
              const size = player.getComponent(SizeComponent);
              document.getElementById(
                'size'
              ).textContent = `Size: ${size.size.toFixed(2)}`;
              const evolution = player.getComponent(EvolutionaryStageComponent);
              const stage =
                evolution.stage.charAt(0).toUpperCase() +
                evolution.stage.slice(1);
              document.getElementById('stage').textContent = `Stage: ${stage}`;
            }
          }

          updateMinimap() {
            const minimap = document.getElementById('minimap');
            const ctx = minimap.getContext('2d');
            ctx.clearRect(0, 0, minimap.width, minimap.height);

            const scale = minimap.width / (this.boundary * 2);

            for (let entity of this.entities) {
              if (entity.hasComponent(PositionComponent)) {
                const position = entity.getComponent(PositionComponent);
                let size = 1;

                if (entity.hasComponent(SizeComponent)) {
                  size = entity.getComponent(SizeComponent).size;
                }

                if (entity.hasComponent(PlayerControlledComponent)) {
                  ctx.fillStyle = 'green';
                } else if (entity.hasComponent(AIControlledComponent)) {
                  ctx.fillStyle = 'white';
                } else if (entity.hasComponent(ObstacleComponent)) {
                  ctx.fillStyle = 'red';
                } else if (entity.hasComponent(PowerUpComponent)) {
                  ctx.fillStyle = 'yellow';
                } else {
                  ctx.fillStyle = 'gray';
                }

                ctx.beginPath();
                ctx.arc(
                  (position.x + this.boundary) * scale,
                  (position.y + this.boundary) * scale,
                  Math.max(size * scale, 1),
                  0,
                  Math.PI * 2
                );
                ctx.fill();
              }
            }
          }

          onWindowResize() {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
          }

          animate(time) {
            requestAnimationFrame((t) => this.animate(t));

            if (this.gameActive) {
              const deltaTime = time - (this.lastTime || time);
              this.lastTime = time;
              this.animationTime += deltaTime * 0.001;

              this.update(deltaTime / 1000);

              if (this.backgroundParticles) {
                this.backgroundParticles.material.uniforms.time.value =
                  this.animationTime;
                this.backgroundParticles.material.uniforms.scale.value =
                  1 + Math.sin(this.animationTime * 0.5) * 0.2;
              }

              for (let entity of this.entities) {
                if (entity.hasComponent(RenderComponent)) {
                  const material =
                    entity.getComponent(RenderComponent).mesh.material;
                  if (material.uniforms && material.uniforms.time) {
                    material.uniforms.time.value = this.animationTime;
                  }
                }
              }

              const currentEnemyCount = this.entities.filter((e) =>
                e.hasComponent(AIControlledComponent)
              ).length;
              for (let i = currentEnemyCount; i < this.enemyCount; i++) {
                this.createAIEntity();
              }

              if (Math.random() < 0.005) this.createPowerUp();

              if (this.score > this.level * 1000) {
                this.level++;
                this.createObstacle();
              }

              this.updateHUD();
              this.updateMinimap();
              createjs.Tween.tick(deltaTime);

              for (let entity of this.entities) {
                if (entity.hasComponent(RenderComponent)) {
                  const material =
                    entity.getComponent(RenderComponent).mesh.material;
                  if (material.uniforms && material.uniforms.time) {
                    material.uniforms.time.value = this.animationTime;
                  }
                }
              }
            }

            this.renderer.render(this.scene, this.camera);
          }
          playSound(soundName) {}

          createAbsorptionEffect(entity) {
            const position = entity.getComponent(PositionComponent);
            const size = entity.getComponent(SizeComponent).size;
            const particleCount = Math.floor(size * 100);

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            const color = new THREE.Color();

            for (let i = 0; i < particleCount; i++) {
              const i3 = i * 3;
              positions[i3] = position.x + (Math.random() - 0.5) * size * 2;
              positions[i3 + 1] = position.y + (Math.random() - 0.5) * size * 2;
              positions[i3 + 2] = position.z + (Math.random() - 0.5) * size * 2;

              color.setHSL(Math.random(), 1, 0.5 + Math.random() * 0.5);
              colors[i3] = color.r;
              colors[i3 + 1] = color.g;
              colors[i3 + 2] = color.b;

              sizes[i] = Math.random() * 2 + 1;
            }

            geometry.setAttribute(
              'position',
              new THREE.BufferAttribute(positions, 3)
            );
            geometry.setAttribute(
              'color',
              new THREE.BufferAttribute(colors, 3)
            );
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
              uniforms: {
                time: { value: 0 },
              },
              vertexShader: this.shaders.particleVertex,
              fragmentShader: this.shaders.particleFragment,
              blending: THREE.AdditiveBlending,
              depthTest: false,
              transparent: true,
            });

            const particleSystem = new THREE.Points(geometry, material);
            this.scene.add(particleSystem);

            const startTime = Date.now();

            const animateParticles = () => {
              const elapsedTime = (Date.now() - startTime) / 1000;
              material.uniforms.time.value = elapsedTime;

              const positions = geometry.attributes.position.array;
              const sizes = geometry.attributes.size.array;

              for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const scale = Math.sin(elapsedTime * 2 + i) * 0.5 + 0.5;

                positions[i3] += Math.sin(elapsedTime + i) * 0.1;
                positions[i3 + 1] += Math.cos(elapsedTime + i) * 0.1;
                positions[i3 + 2] += Math.sin(elapsedTime * 2 + i) * 0.1;

                sizes[i] = (Math.sin(elapsedTime * 3 + i) * 0.5 + 0.5) * 3 + 1;
              }

              geometry.attributes.position.needsUpdate = true;
              geometry.attributes.size.needsUpdate = true;

              if (elapsedTime < 3) {
                requestAnimationFrame(animateParticles);
              } else {
                this.scene.remove(particleSystem);
              }
            };

            animateParticles();
          }
          createEvolutionEffect(entity) {
            const position = entity.getComponent(PositionComponent);
            const size = entity.getComponent(SizeComponent).size;

            const ringGeometry = new THREE.RingGeometry(size, size + 0.5, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
              color: 0xffffff,
              side: THREE.DoubleSide,
              transparent: true,
              opacity: 0.7,
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.set(position.x, position.y, position.z);
            this.scene.add(ring);

            const tween = new createjs.Tween.get(ring.scale)
              .to({ x: 2, y: 2, z: 2 }, 1000, createjs.Ease.quadOut)
              .call(() => {
                this.scene.remove(ring);
              });

            const opacityTween = new createjs.Tween.get(ringMaterial).to(
              { opacity: 0 },
              1000,
              createjs.Ease.quadIn
            );
          }

          createWormholeEffect(entity) {
            const position = entity.getComponent(PositionComponent);

            const spiralGeometry = new THREE.TorusKnotGeometry(2, 0.5, 100, 16);
            const spiralMaterial = new THREE.MeshBasicMaterial({
              color: 0x9900ff,
              transparent: true,
              opacity: 0.7,
            });
            const spiral = new THREE.Mesh(spiralGeometry, spiralMaterial);
            spiral.position.set(position.x, position.y, position.z);
            this.scene.add(spiral);

            const tween = new createjs.Tween.get(spiral.rotation)
              .to(
                { x: Math.PI * 2, y: Math.PI * 2 },
                1000,
                createjs.Ease.quadInOut
              )
              .call(() => {
                this.scene.remove(spiral);
              });

            const scaleTween = new createjs.Tween.get(spiral.scale).to(
              { x: 0, y: 0, z: 0 },
              1000,
              createjs.Ease.quadIn
            );
          }

          createSpaceDustEffect(position) {
            const particleCount = 20;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            for (let i = 0; i < particleCount; i++) {
              const i3 = i * 3;
              positions[i3] = position.x + (Math.random() - 0.5) * 0.2;
              positions[i3 + 1] = position.y + (Math.random() - 0.5) * 0.2;
              positions[i3 + 2] = position.z + (Math.random() - 0.5) * 0.2;

              sizes[i] = Math.random() * 0.05 + 0.02;
            }

            geometry.setAttribute(
              'position',
              new THREE.BufferAttribute(positions, 3)
            );
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.ShaderMaterial({
              uniforms: {
                time: { value: 0 },
              },
              vertexShader: this.shaders.spaceDustVertex,
              fragmentShader: this.shaders.spaceDustFragment,
              blending: THREE.AdditiveBlending,
              depthTest: false,
              transparent: true,
            });

            const particleSystem = new THREE.Points(geometry, material);
            this.scene.add(particleSystem);

            const startTime = Date.now();

            const animateSpaceDust = () => {
              const elapsedTime = (Date.now() - startTime) / 1000;
              material.uniforms.time.value = elapsedTime;

              const positions = geometry.attributes.position.array;
              const sizes = geometry.attributes.size.array;

              for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const scale = Math.sin(elapsedTime * 2 + i) * 0.5 + 0.5;

                positions[i3] += Math.sin(elapsedTime + i) * 0.001;
                positions[i3 + 1] += Math.cos(elapsedTime + i) * 0.001;
                positions[i3 + 2] += Math.sin(elapsedTime * 2 + i) * 0.001;

                sizes[i] =
                  (Math.sin(elapsedTime * 3 + i) * 0.5 + 0.5) * 0.05 + 0.02;
              }

              geometry.attributes.position.needsUpdate = true;
              geometry.attributes.size.needsUpdate = true;

              particleSystem.scale.set(
                1 + elapsedTime * 2,
                1 + elapsedTime * 2,
                1 + elapsedTime * 2
              );

              if (elapsedTime < 0.5) {
                requestAnimationFrame(animateSpaceDust);
              } else {
                this.scene.remove(particleSystem);
              }
            };

            animateSpaceDust();
          }
        }

        const world = new World();
        world.animate(0);
      };
    </script>
    <script>
      !function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).HCSRecusionSDK={})}(this,(function(t){"use strict";const e=t=>new Promise((e=>setTimeout(e,t))),a={config:{cdnUrl:"https://tier.bot/api/hashinals-cdn/",network:"mainnet",retryAttempts:3,retryBackoff:300,debug:!1,showLoadingIndicator:!1,loadingCallbackName:null},configMapping:{hcsCdnUrl:"cdnUrl",hcsNetwork:"network",hcsRetryAttempts:"retryAttempts",hcsRetryBackoff:"retryBackoff",hcsDebug:"debug",hcsShowLoadingIndicator:"showLoadingIndicator",hcsLoadingCallbackName:"loadingCallbackName"},LoadedScripts:{},LoadedWasm:null,LoadedImages:{},LoadedVideos:{},LoadedAudios:{},LoadedAudioUrls:{},LoadedGLBs:{},scriptLoadedEvent:new Event("HCSScriptLoaded"),loadQueue:[],isProcessingQueue:!1,log(...t){this.config.debug&&console.log("[HCS SDK]",...t)},error(...t){console.error("[HCS SDK]",...t)},loadConfigFromHTML(){const t=document.querySelector("script[data-hcs-config]");t&&Object.keys(this.configMapping).forEach((e=>{if(t.dataset[e]){const a=this.configMapping[e];let i=t.dataset[e];"true"===i&&(i=!0),"false"===i&&(i=!1),isNaN(Number(i))||""===i||(i=Number(i)),this.config[a]=i}})),this.log("Loaded config:",this.config)},updateLoadingStatus(t,e){"loaded"!==this.LoadedScripts[t]&&(this.config.showLoadingIndicator&&console.log("[HCS Loading] "+t+" : "+e),this.LoadedScripts[t]=e,this.config.loadingCallbackName&&"function"==typeof window[this.config.loadingCallbackName]&&window[this.config.loadingCallbackName](t,e))},async fetchWithRetry(t,a=this.config.retryAttempts,i=this.config.retryBackoff){try{const e=await fetch(t);if(!e.ok)throw new Error("HTTP error! status: "+e.status);return e}catch(o){if(a>0)return this.log("Retrying fetch for "+t+" Attempts left: "+(a-1)),await e(i),this.fetchWithRetry(t,a-1,2*i);throw o}},isDuplicate(t){return!!this.LoadedScripts[t]},async loadScript(t){const e=t.getAttribute("data-src"),a=t.getAttribute("data-script-id"),i=null==e?void 0:e.split("/").pop(),o=t.getAttribute("type"),d=t.hasAttribute("data-required");if(!this.isDuplicate(i||"")){this.updateLoadingStatus(a,"loading");try{const e=t.getAttribute("data-cdn-url")||this.config.cdnUrl,s=t.getAttribute("data-network")||this.config.network,n=await this.fetchWithRetry(e+i+"?network="+s);if("wasm"===o){const e=await n.arrayBuffer(),i=await WebAssembly.compile(e);this.LoadedWasm=await WebAssembly.instantiate(i,{env:{},...t.dataset}),this.updateLoadingStatus(a,"loaded"),window.dispatchEvent(this.scriptLoadedEvent),this.log("Loaded wasm: "+a)}else{const t=await n.text(),e=document.createElement("script");e.textContent=t,document.body.appendChild(e),this.updateLoadingStatus(a,"loaded"),window.dispatchEvent(this.scriptLoadedEvent),this.log("Loaded script: "+a),e.onerror=t=>{if(this.error("Failed to load "+o+": "+a,t),this.updateLoadingStatus(a,"failed"),d)throw t}}}catch(s){if(this.error("Failed to load "+o+": "+a,s),this.updateLoadingStatus(a,"failed"),d)throw s}}},async loadStylesheet(t){const e=t.getAttribute("data-src"),a=t.getAttribute("data-script-id"),i=null==e?void 0:e.split("/").pop(),o=t.hasAttribute("data-required");if(!this.isDuplicate(i||"")){this.updateLoadingStatus(a,"loading");try{const e=t.getAttribute("data-cdn-url")||this.config.cdnUrl,o=t.getAttribute("data-network")||this.config.network,d=await this.fetchWithRetry(e+i+"?network="+o),s=await d.text(),n=document.createElement("style");n.textContent=s,document.head.appendChild(n),this.updateLoadingStatus(a,"loaded"),window.dispatchEvent(this.scriptLoadedEvent),this.log("Loaded and inlined stylesheet: "+a)}catch(d){if(this.error("Failed to load stylesheet: "+a,d),this.updateLoadingStatus(a,"failed"),o)throw d}}},async loadImage(t){const e=t.getAttribute("data-src"),a=null==e?void 0:e.split("/").pop();this.log("Loading image: "+a),this.updateLoadingStatus("Image: "+a,"loading");try{const e=t.getAttribute("data-cdn-url")||this.config.cdnUrl,i=t.getAttribute("data-network")||this.config.network,o=await this.fetchWithRetry(e+a+"?network="+i),d=await o.blob(),s=URL.createObjectURL(d);t.src=s,this.LoadedImages[a]=s,this.updateLoadingStatus("Image: "+a,"loaded"),this.log("Loaded image: "+a)}catch(i){this.error("Failed to load image: "+a,i),this.updateLoadingStatus("Image: "+a,"failed")}},async loadMedia(t,e){const a=t.getAttribute("data-src"),i=null==a?void 0:a.split("/").pop();this.log("Loading "+e+": "+i),this.updateLoadingStatus(e+": "+i,"loading");try{const a=t.getAttribute("data-cdn-url")||this.config.cdnUrl,o=t.getAttribute("data-network")||this.config.network,d=await this.fetchWithRetry(a+i+"?network="+o),s=await d.blob(),n=URL.createObjectURL(s);t.src=n,"video"===e?this.LoadedVideos[i]=n:this.LoadedAudios[i]=n,this.updateLoadingStatus(e+": "+i,"loaded"),this.log("Loaded "+e+": "+i)}catch(o){this.error("Failed to load "+e+": "+i,o),this.updateLoadingStatus(e+": "+i,"failed")}},async loadGLB(t){const e=t.getAttribute("data-src"),a=null==e?void 0:e.split("/").pop();this.log("Loading GLB: "+a),this.updateLoadingStatus("GLB: "+a,"loading");try{const e=t.getAttribute("data-cdn-url")||this.config.cdnUrl,i=t.getAttribute("data-network")||this.config.network,o=await this.fetchWithRetry(e+a+"?network="+i),d=await o.blob(),s=URL.createObjectURL(d);t.src=s,this.LoadedGLBs[a]=s,this.updateLoadingStatus("GLB: "+a,"loaded"),this.log("Loaded GLB: "+a)}catch(i){this.error("Failed to load GLB: "+a,i),this.updateLoadingStatus("GLB: "+a,"failed")}},async processQueue(){if(!this.isProcessingQueue){for(this.isProcessingQueue=!0;this.loadQueue.length>0;){const e=this.loadQueue.shift();try{"script"===e.type?await this.loadScript(e.element):"image"===e.type?await this.loadImage(e.element):"video"===e.type||"audio"===e.type?await this.loadMedia(e.element,e.type):"glb"===e.type?await this.loadGLB(e.element):"css"===e.type&&await this.loadStylesheet(e.element)}catch(t){if(this.error("Error processing queue item:",t),"script"===e.type&&e.element.hasAttribute("data-required"))break}}this.isProcessingQueue=!1}},queueLoading(t,e){t.forEach((t=>{const a=parseInt(t.getAttribute("data-load-order")||"")||1/0;this.loadQueue.push({element:t,type:e,order:a})})),this.loadQueue.sort(((t,e)=>t.order-e.order)),this.processQueue()},init(){return this.loadConfigFromHTML(),new Promise((t=>{const e=()=>{const e=document.querySelectorAll('script[data-src^="hcs://"]'),a=document.querySelectorAll('img[data-src^="hcs://"]'),i=document.querySelectorAll('video[data-src^="hcs://"]'),o=document.querySelectorAll('audio[data-src^="hcs://"]'),d=document.querySelectorAll('model-viewer[data-src^="hcs://"]'),s=document.querySelectorAll('link[data-src^="hcs://"]');this.queueLoading(e,"script"),this.queueLoading(a,"image"),this.queueLoading(i,"video"),this.queueLoading(o,"audio"),this.queueLoading(d,"glb"),this.queueLoading(s,"css");const n=new MutationObserver((t=>{t.forEach((t=>{t.addedNodes.forEach((t=>{if(t.nodeType===Node.ELEMENT_NODE){const e=t;e.matches('script[data-src^="hcs://"]')?this.queueLoading([e],"script"):e.matches('img[data-src^="hcs://"]')?this.queueLoading([e],"image"):e.matches('video[data-src^="hcs://"]')?this.queueLoading([e],"video"):e.matches('audio[data-src^="hcs://"]')?this.queueLoading([e],"audio"):e.matches('model-viewer[data-src^="hcs://"]')?this.queueLoading([e],"glb"):e.matches('link[data-src^="hcs://"]')&&this.queueLoading([e],"css")}}))}))}));document.body?n.observe(document.body,{childList:!0,subtree:!0}):document.addEventListener("DOMContentLoaded",(()=>{n.observe(document.body,{childList:!0,subtree:!0})}));const r=()=>{0===this.loadQueue.length?t():requestAnimationFrame(r)};r()};"loading"===document.readyState?document.addEventListener("DOMContentLoaded",e):e()}))},async preloadAudio(t){const e=document.createElement("audio");e.setAttribute("data-topic-id",t),e.setAttribute("data-src","hcs://1/"+t),document.body.appendChild(e),await window.HCS.loadMedia(e,"audio");const a=document.querySelector('audio[data-topic-id="'+t+'"]');a?window.HCS.LoadedAudioUrls[t]=a.src:console.error("Failed to preload audio: "+t)},async playAudio(t,e=1){var a,i;const o=null==(i=null==(a=null==window?void 0:window.HCS)?void 0:a.LoadedAudioUrls)?void 0:i[t];if(o){const a=new Audio(o);a.volume=e,window.HCS.LoadedAudios[t]=a,a.play().catch((t=>{console.error("Failed to play audio:",t)})),a.addEventListener("ended",(()=>{a.remove(),delete window.HCS.LoadedAudios[t]}))}else console.error("Audio not preloaded: "+t)},async pauseAudio(t){var e,a,i,o,d,s;const n=document.querySelector('audio[data-topic-id="'+t+'"]');n?(console.log("found element",n),n.pause(),null==(i=null==(a=null==(e=null==window?void 0:window.HCS)?void 0:e.LoadedAudios)?void 0:a[t])||i.pause()):null==(s=null==(d=null==(o=null==window?void 0:window.HCS)?void 0:o.LoadedAudios)?void 0:d[t])||s.pause()},async loadAndPlayAudio(t,e=!1,a=1){let i=document.querySelector('audio[data-topic-id="'+t+'"]');if(i)i.volume=a,await i.play();else{const o=document.createElement("audio");o.volume=a,e&&o.setAttribute("autoplay","autoplay"),o.setAttribute("data-topic-id",t),o.setAttribute("data-src","hcs://1/"+t),document.body.appendChild(o),await this.loadMedia(o,"audio"),i=document.querySelector('audio[data-topic-id="'+t+'"]'),e||await i.play()}}};window.HCS=a,a.init().then((()=>{console.log("All HCS resources loaded",window.HCSReady),"function"==typeof window.HCSReady&&(console.log("running start.."),window.HCSReady())})),t.sleep=e,Object.defineProperty(t,Symbol.toStringTag,{value:"Module"})}));
    </script>
  </body>
</html>
